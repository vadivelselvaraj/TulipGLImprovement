#!/bin/sh

# This script is MAC specific:
# with no parameter it intents to create an internet deliverable
# disk image of a tulip MAC 'bundle' in the current directory
# with 1 parameter, it considers $1
# as a plugin lib we want to package for a further
# download with the plugins server

APP_DIR=Tulip-@PACKAGE_VERSION@.app
QT_DIR=@QTDIR@

BIN_BUNDLE_DIR=$APP_DIR/Contents/MacOS
BIN_BUNDLE=$BIN_BUNDLE_DIR/tulip
LIBS_BUNDLE_DIR=$APP_DIR/Contents/Frameworks
RESOURCES_BUNDLE_DIR=$APP_DIR/Contents/Resources
BUNDLE_LIB_PATH=@executable_path/../Frameworks
SHLIBS_REGEXP="dylib \|/4/Qt"

# the first parameter $slib is a library
# the third parameter $bbin depends on
# if $slib does not already exists in
# $slibdir (second parameter) and we are not
# in check mode (fourth parameter), it is copied in it
# and internally renamed
# finally the corresponding dependance in $bbin is updated
function make_bundle_lib() {
  slib=$1
  slibdir=$2
  bbin=$3
  if [ $# -eq 3 ]; then
   check_slib=0
  else
   check_slib=$4
  fi

  oldlib=$slib
  if [ "$slib" = "*System*" ]; then
   return
  fi
  if [ "$slib" = "/usr/lib/libSystem.B.dylib" ]; then
   return
  fi
  if [ ! -f $slib ]; then
    if [ -f /usr/lib/$slib ]; then
      slib=/usr/lib/$slib
    else
      slib=/Library/Frameworks/$slib
    fi
  fi

  if [ -f $slib ]; then
    if [ ! -f $slibdir/`basename $slib` ]; then
      if [ $check_slib -eq 0 ]; then
        cp $slib $slibdir
	slib=`basename $slib`
	chmod 755 $slibdir/$slib
	echo installing $slib in $slibdir
        # update the name of the current bundle lib
        install_name_tool -id $BUNDLE_LIB_PATH/$slib $slibdir/$slib
      else
	echo `basename $slib` not found... exiting
        exit
      fi
    else
       slib=`basename $slib`
    fi
    echo renaming $slib in `basename $bbin`
    # package tulip bundle binary with the current bundle lib
    install_name_tool -change $oldlib $BUNDLE_LIB_PATH/$slib $bbin
  else
    echo `basename $slib` not found... exiting
    exit
  fi
}

function package_bundle_lib() {
  fdir=$1
  blib=$2
  if [ $# -eq 2 ]; then
   check_slib=0
  else
   check_slib=$3
  fi

  blibname=`basename $blib`
  slibs=$(otool -L $blib | grep "$SHLIBS_REGEXP" | awk '{print $1}')
  for slib in $slibs
  do
    slibname=`basename $slib`
    if [ "$slibname" = "$blibname" ]; then
	continue
    fi
    if [ "/$slibname" = "${slib#$BUNDLE_LIB_PATH}" ]; then
	continue
    fi
    make_bundle_lib $slib $fdir $blib $check_slib
  done
}

function package_bundle_libs() {
  blibdir=$1
  if [ $# -eq 1 ]; then
    name_regexp='*'
  else
    name_regexp=$2
  fi
  blibs=$(find $blibdir  -name "$name_regexp" -a -type f -print)
  if [ $# -lt 3 ]; then
    fdir=$1
  else
    fdir=$3
  fi
  for blib in $blibs
  do
    package_bundle_lib $fdir $blib
  done
}

# if $1 exists it has to be a plugin lib
# to package for further download with the
# plugins server
if [ $# -eq 1 ]; then
  package_bundle_lib $LIBS_BUNDLE_DIR $1
  exit
fi

if [ -d $APP_DIR ]; then
  rm -rf $APP_DIR
fi

# copy the tulip app installed in @prefix@/bin
echo installing $APP_DIR
cp -RL @prefix@/bin/tulip.app .
mv tulip.app $APP_DIR

# create the tulip shared libs bundle directory
mkdir -p $LIBS_BUNDLE_DIR
# look for shared libs
SHARED_LIBS=$(otool -L $BIN_BUNDLE | grep "$SHLIBS_REGEXP" | awk '{print $1}')
# copy libs in shared libs bundle directory
for LIB in $SHARED_LIBS
do
  make_bundle_lib $LIB $LIBS_BUNDLE_DIR $BIN_BUNDLE
done
# same for tulip_check_pl
# look for shared libs
SHARED_LIBS=$(otool -L $BIN_BUNDLE_DIR/tulip_check_pl | grep "$SHLIBS_REGEXP" | awk '{print $1}')
# copy libs in shared libs bundle directory
for LIB in $SHARED_LIBS
do
  make_bundle_lib $LIB $LIBS_BUNDLE_DIR $BIN_BUNDLE_DIR/tulip_check_pl
done


# clean up the plugins bundle dir
TLP_PLUGINS_BUNDLE_DIR=$APP_DIR/Contents/lib/tlp
# remove lib*.a and lib*.la files
find $TLP_PLUGINS_BUNDLE_DIR -name 'lib*.*a' -print | xargs rm
find $TLP_PLUGINS_BUNDLE_DIR -name "lib*-@PACKAGE_VERSION@" -print | xargs rm
# remove the plugins designer bundle dir
# rm -rf $TLP_PLUGINS_BUNDLE_DIR/designer
# package the lib*.dylib files
package_bundle_libs $TLP_PLUGINS_BUNDLE_DIR '*.dylib' $LIBS_BUNDLE_DIR

# copy Qt assistant application
if [ "$QT_DIR" == "" ]; then
  QT_DIR=/Developer/Applications/Qt
  QT_ASSISTANT=Assistant
fi
ASSISTANT_BUNDLE_DIR=$APP_DIR/Contents/@QT_ASSISTANT@.app
ASSISTANT_LIBS_BUNDLE_DIR=$ASSISTANT_BUNDLE_DIR/Contents/Frameworks
ASSISTANT_BIN_BUNDLE=$ASSISTANT_BUNDLE_DIR/Contents/MacOS/@QT_ASSISTANT@
echo packaging $ASSISTANT_BUNDLE_DIR
mkdir $ASSISTANT_LIBS_BUNDLE_DIR
#update assistant binary and libs
SHARED_LIBS=$(otool -L $ASSISTANT_BIN_BUNDLE | grep "$SHLIBS_REGEXP" | awk '{print $1}')
# copy libs in shared libs bundle directory
for LIB in $SHARED_LIBS
do
  make_bundle_lib $LIB $ASSISTANT_LIBS_BUNDLE_DIR $ASSISTANT_BIN_BUNDLE
done
# package assistant shared libs
package_bundle_libs $ASSISTANT_LIBS_BUNDLE_DIR

# copy Qt imageformats plugins
QT_IMG_PLUGINS_LIBDIR=$APP_DIR/Contents/imageformats
mkdir $QT_IMG_PLUGINS_LIBDIR
cp $QT_DIR/plugins/imageformats/lib*.dylib $QT_IMG_PLUGINS_LIBDIR
package_bundle_libs $QT_IMG_PLUGINS_LIBDIR '*.dylib' $LIBS_BUNDLE_DIR

# package tulip shared libs
package_bundle_libs $LIBS_BUNDLE_DIR
# do it twice because of possibly newly installed files
# during first try 
package_bundle_libs $LIBS_BUNDLE_DIR

# create disk image with our bundle
echo creating Tulip-@PACKAGE_VERSION@.dmg disk image
hdiutil create -srcdir $APP_DIR -format UDZO -fs HFS+ -volname Tulip-@PACKAGE_VERSION@ -ov Tulip-@PACKAGE_VERSION@.dmg
# then internet enabled it
hdiutil internet-enable -yes Tulip-@PACKAGE_VERSION@.dmg
