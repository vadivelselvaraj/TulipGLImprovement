<?xml version='1.0'?>
<!--<!DOCTYPE book PUBLIC "-//OASIS//DTD Docbook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">-->
<!DOCTYPE book PUBLIC "-//OASIS//DTD Docbook XML V4.4//EN" "../common/dtd/docbookx.dtd">

<book><bookinfo><title>Tulip Developer Handbook</title></bookinfo>
<chapter id="introduction"><title>Introduction</title>
    <para></para>
</chapter>
<chapter id="installation"><title>Installation</title>

   <para>The <quote>configure</quote> shell script attempts to guess correct values for
various system-dependent variables used during compilation.  It uses
those values to create a <quote>Makefile</quote> in each directory of the package.
It may also create one or more <quote>.h</quote> files containing system-dependent
definitions.  Finally, it creates a shell script <quote>config.status</quote> that
you can run in the future to recreate the current configuration, a file
<quote>config.cache</quote> that saves the results of its tests to speed up
reconfiguring, and a file <quote>config.log</quote> containing compiler output
(useful mainly for debugging <quote>configure</quote>).</para>

   <para>If you need to do unusual things to compile the package, please try
to figure out how <quote>configure</quote> could check whether to do them, and mail
diffs or instructions to the address given in the <quote>README</quote> so they can
be considered for the next release.  If at some point <quote>config.cache</quote>
contains results you don't want to keep, you may remove or edit it.</para>

   <para>The file <quote>configure.in</quote> is used to create <quote>configure</quote> by a program
called <quote>autoconf</quote>.  You only need <quote>configure.in</quote> if you want to change
it or regenerate <quote>configure</quote> using a newer version of <quote>autoconf</quote>.</para>

<para><orderedlist><title>The simplest way to compile this package is:</title>

  <listitem><para><quote>cd</quote> to the directory containing the package's source code and type
     <quote>./configure</quote> to configure the package for your system.  If you're
     using <quote>csh</quote> on an old version of System V, you might need to type
     <quote>sh ./configure</quote> instead to prevent <quote>csh</quote> from trying to execute
     <quote>configure</quote> itself.</para>

     <para>Running <quote>configure</quote> takes awhile.  While running, it prints some
     messages telling which features it is checking for.</para></listitem>

  <listitem><para>Type <quote>make</quote> to compile the package.</para></listitem>

  <listitem><para>Optionally, type <quote>make check</quote> to run any self-tests that come with
     the package.</para></listitem>

  <listitem><para>Type <quote>make install</quote> to install the programs and any data files and
     documentation.</para></listitem>

  <listitem><para>You can remove the program binaries and object files from the
     source code directory by typing <quote>make clean</quote>.  To also remove the
     files that <quote>configure</quote> created (so you can compile the package for
     a different kind of computer), type <quote>make distclean</quote>.  There is
     also a <quote>make maintainer-clean</quote> target, but that is intended mainly
     for the package's developers.  If you use it, you may have to get
     all sorts of other programs in order to regenerate files that came
     with the distribution.</para></listitem></orderedlist>
</para>

<para>If you don't find the <quote>configure</quote> shell, you have to generate it with "gen-conf.sh". The processing using the GNU build sytem gives a <quote>configure</quote> shell.</para>

    <sect1 id="environment"><title>Environment variables</title>
        <para>QTDIR, LD_LIBRARY_PATH</para>
    </sect1>
    <sect1 id="options"><title>Options</title>

        <itemizedlist>
            <listitem><para>--prefix=<emphasis>value</emphasis>, The <emphasis>value</emphasis> is the path where you want to install Tulip. <filename>bin, include, lib</filename> directories was created in this location. By default, it is <filename>/usr/local/</filename></para></listitem>
            <listitem><para>--enable-debug</para></listitem>
        </itemizedlist>
        <para> To modify the compilation or installation processing, you have to use the GNU build system, see <xref linkend="build-sys"/> which explain how to make some modifications and the reference you can use. </para>
    </sect1>

</chapter>
<chapter id="data-structure"><title>Data Structure</title>
<para>Efficient visualization of graphs implies to manipulate the structure of 
the graph but also to extract part of this structure. Moreover, if one 
wants to visualize graphs and to use graphs for data analysis, one must
take into account the values associated to the element (node or edge) of the 
graph. One other central point in a visualization system is to provide a 
way to compute parameters based on the intrinsic (or extrinsic) parameters
of a given graph. We call intrinsic parameters those calculated by using the
structure of the graph and extrinsic parameters those calculated using external
information. For instance, if we consider a file system, the size of a file is
an extrinsic parameter and the number of file in a directory is an intrinsic parameter 
because in can be computed by analyzing the structure of the tree representing the file system.  
</para>
<para>
This chapter describes the Tulip data structure that takes into account all the requirement
of a graph visualization system. For each part we describe precisely the general principle and
then we give several examples explaining how it can be done using the Tulip library.
</para>

<sect1 id="graphs"><title>Graphs</title>
    <para>The core of the Tulip library provides an interface for the manipulation of graphs. This interface enables
to access and to modify the structure of a graph. The objective of this library is to be the more general 
as possible and thus this interface enables to manipulate a general class of graphs called directed pseudo-graph. 
In a pseudo graph, it can exists several edges between two nodes and it can exists several loops. A loop is an
edge that links a node to itself. Furthermore, the link are directed, thus an edge linking a node u to a node v is
different from an edge linking a node v to a node u. 
    </para>
    <para>
    Using of pseudo-graph implies that it can exist two edge between a node u and a node v. Thus, it is not possible to
distinguish an edge using only its source and its target (u,v). To enable such a distinction, all the element in Tulip
are entities (objects). Thus, even if two edges have the same source and the same target they are different.    
    </para>
    <para>
Another important point to consider is that it is not possible to access to the structure of a graph through elements 
(node or edge). Thus, all operations on the graph structure must be done by querying the graph. For instance, if one
wants to know the source of an edge e of graph G, one must ask to G what is the source of e. This characteristic makes
the use of the library a little bit less intuitive but, it enables to store entities using the minimum space and to 
share them between sub-graphs. When using the Tulip data structure one must always keep in mind that building a container 
of elements corresponds to store a container of integers in memory. For instance, a std::vector&lt;node&gt; is 
equivalent to a std::vector&lt;unsigned int&gt;. 
    </para>
    <para>
The library support access and modification of the graph structure. The access to the structure are made by using iterators,
one very important point is that the iterator are not persistent. Thus, if one modify the graph structure all the iterators
on the graph structure can be invalid. This property enables to prevent from cloning the data structure and thus enables 
better access to it. For ease of use, Tulip includes mechanism that enables to transform an iterator into stable iterator,
one must keep in mind that it corresponds to clone the data structure and thus, it should be use only if it is necessary.
    </para>
    <para>
If one use Tulip only for the manipulation of one graph (no hierarchy), the list of available operations on the 
graph is given afterward. In the next section we will enhance the set of operations and the actions that they perform 
in order to manage a hierarchy of sub graphs
    <itemizedlist>
    <title>List of available modification operations</title>
    <listitem><para><methodname>node addNode()</methodname> : it enables to create a new node in the graph.</para></listitem>
    <listitem><para>    
        <methodname>edge addEdge(node,node)</methodname> : it enables to create a new edge in the graph. </para></listitem>
    <listitem><para><methodname>void delNode(node)</methodname> : it enables to delete a node in the graph.</para></listitem>
    <listitem><para><methodname>void delEdge(edge)</methodname> : it enables to delete an edge in the graph.</para></listitem>
    <listitem><para><methodname>void reverse(edge)</methodname> : it enables to reverse an edge (swap source and target).</para></listitem>
    </itemizedlist>
    <itemizedlist>
    <title>List of available access operations</title>
    <listitem><para><methodname>unsigned int deg(node)</methodname> : returns the degree of a node.</para></listitem>
    <listitem><para><methodname>unsigned int indeg(node)</methodname> : returns the in degree of a node.</para></listitem>
    <listitem><para><methodname>unsigned int outdeg(node)</methodname> : returns the out degree of a node.</para></listitem>
    <listitem><para><methodname>node source(edge)</methodname> : it returns the source of an edge.</para></listitem>
    <listitem><para><methodname>node target(edge)</methodname> : it returns the target of an edge.</para></listitem>
    <listitem><para><methodname>void opposite(edge,node)</methodname> : it enables to obtain the opposite of a node of an edge.</para></listitem>
    <listitem><para><methodname>Iterator * getInNodes(node)</methodname> : returns an iterator on the ancestors of a node.</para></listitem>
    <listitem><para><methodname>Iterator * getOutNodes(node)</methodname> : returns an iterator on the successors of a node.</para></listitem>
    <listitem><para><methodname>Iterator * getInOutNodes(node)</methodname> : returns an iterator on the neighborhood of a node.</para></listitem>
    <listitem><para><methodname>Iterator * getInEdges(node)</methodname> : returns an iterator on the ancestors of a node.</para></listitem>
    <listitem><para><methodname>Iterator * getOutEdges(node)</methodname> : returns an iterator on the successors of a node.</para></listitem>
    <listitem><para><methodname>Iterator * getInOutEdges(node)</methodname> : returns an iterator on the neighborhood of a node.</para></listitem>
    </itemizedlist>
    </para>
</sect1>

<sect1 id="hierarchy-graphs"><title>Hierarchy of graphs</title>
    <para> The Tulip library integrates the management of sub graphs. By definition a sub graph G' of a graph G is part of 
the elements of G such that G' is a graph. This implies that all sources and target of the edges of G' are in G'. 
Thus a sub graph can be manipulated exactly like a graph and so in Tulip one will only manipulates graphs that
we call SuperGraph because they could be or not sub graphs. As a sub graph is a graph one can need to obtain 
a sub graph of this sub graph and so on. Such an operation consists in building of a hierarchy of graphs. In this 
hierarchy if a graph G" is a descendant of a graph G, G" is a sub graph of G.
    </para>
    <para> One of the strong point of Tulip is to ensure efficiently that all elements are shared between graphs in a hierarchy
of graph. Thus, if a node n is element of a graph G and of a graph G' the entity n is the same in both graphs. Off course,
the information about the entity can changed between graphs. For instance, the degree of n can be different according to
the graph that we manipulate.
    </para>
    <para> One of the other feature in Tulip is that the sub graph relation in the hierarchy is preserved when one
makes modification of a graph. This requirement implies some change on the modification operations described above.
If one add a node in a graph, this node is automatically added to all the ancestor of this graph. If one delete a
node, this node is automatically deleted in all the descendant of the graph. If one reverse an edge, this edge is 
automatically reversed in all the hierarchy of graphs.
    </para>
    <para> In order to manipulate a hierarchy of graphs, a set of functions have been added to graph function introduced
above. This function enables to navigate in the hierarchy and also to modify the hierarchy of graphs. As for the
graph structure the access to the hierarchy structure is done by using iterators. One should remember that iterators
are not persistent and thus, if the hierarchy is modified, the iterators are invalid.
    <itemizedlist>
    <title>List of available modification operations</title>
    <listitem><para><methodname>SuperGraph *addSubGraph()</methodname> : return an empty sub graph of this graph.</para></listitem>
    <listitem><para><methodname>SuperGraph *delSubGraph(SuperGraph *)</methodname> : delete a sub graph, the descendant of this sub graph 
    continue to be sub graphs of the graph.</para></listitem>
    <listitem><para><methodname>SuperGraph *delAllSubGraph(SuperGraph *)</methodname> : delete a sub graph and all its descendant.</para></listitem>
    <listitem><para><methodname>edge addEdge(edge)</methodname> : add an edge element of another graph in the hierarchy.</para></listitem>
    <listitem><para><methodname>void addNode(node)</methodname> : add a node element of another graph in the hierarchy.</para></listitem>
    </itemizedlist>
    <itemizedlist>
    <title>List of available access operations</title>
    <listitem><para><methodname>Iterator * getSubGraphs()</methodname> : returns an iterator on the sub graphs.</para></listitem>
    <listitem><para><methodname>SuperGraph * getFather()</methodname> : returns the ancestor of the graph if the graph haven't got
    ancestor, it returns itself.</para></listitem>
    </itemizedlist>
    </para>
</sect1>

<sect1 id="attributes"><title>Attributes</title><para></para></sect1>

<sect1 id="properties"><title>Properties</title>
    <para> The Tulip property enables to store attribute on the elements of a graph. In Tulip we call it Property in 
order to prevent confusion with the graph attribute. Thus, the properties are for the elements and attributes are
for the graphs. The main idea in Tulip is that a property is always define for all kind (node and edge) of elements
in the graph. Thus we can always query for the value of an edge or a node to a property.
    </para>
    <para> As for the graph structure, to access the value of an elements one must query a property. This characteristic makes
the use of the library a little bit less intuitive but, it enables to store efficiently the properties. 
    </para>
    <para>
In general properties
can be seen as an associative table where you can set or get the value of an element. In order to prevent having a lot of cast 
in the code all the properties have type and thus there is no need to cast your result when you query a property. The standard
operation of a property are given below :
    <itemizedlist>
    <title>List of available modification operations</title>
    <listitem><para><methodname>void setNodeValue(node,TYPE)</methodname> : set the value of a node.</para></listitem>
    <listitem><para><methodname>void setAllNodeValue(TYPE)</methodname> : set the value of all nodes.</para></listitem>
    <listitem><para><methodname>void setEdgeValue(edge,TYPE)</methodname> : set the value of an edge.</para></listitem>
    <listitem><para><methodname>void setAllEdgeValue(TYPE)</methodname> : set the value of all edges.</para></listitem>
    </itemizedlist>
    <itemizedlist>
    <title>List of available access operations</title>
    <listitem><para><methodname>TYPE getNodeValue(node)</methodname> : return the value of a node.</para></listitem>
    <listitem><para><methodname>TYPE getEdgeValue(edge)</methodname> : return the value of an edge.</para></listitem>
    </itemizedlist>
    </para>
    <para> For each kind of properties it exists a specific implementation (inheritance) that enables to obtain
    specific operations (see developer documentation) depending of the Type. For instance, it is possible to obtain 
    the maximum value of a property if it a double. 
    </para>
    <para> One of the most important things is to know how to create a property or to access to an existing property
in the graph. To do this a graph includes a set of functions that enables to obtain/create/delete a Property. Because
the C++ signature of function does not include the TYPE of the returned argument, the syntax for this call is not 
very simple. For instance, if one wants to obtain a property containing double (called MetricProxy in Tulip) one must use
the following syntax : <methodname> MetricProxy *metric=graph->getProperty&lt;MetricProxy&gt;("name of the property");</methodname>
In the graph each properties are identified by their name which a std::string, when one ask for a property the type of this 
property is checked using the run time type interrogation mechanism of the C++. Warning, this test is only done when one 
compile its sources in DEBUG mode (default mode). In order to facilitate the navigation/edition of the set of properties, a
set of function is accessible through the graph interface.
    <itemizedlist>
    <title>List of available operations</title>
    <listitem><para><methodname>Iterators * getLocalProperties()</methodname> : return an iterator on all existing properties.</para></listitem>
    <listitem><para><methodname>void delLocalProperty(std::string)</methodname> : delete a property.</para></listitem>
    <listitem><para><methodname>bool existLocalProperty(std::string)</methodname> : return true if the property exists.</para></listitem>
    <listitem><para><methodname>Proxytype * getLocalProperty (std::string)</methodname> : return the property or if it does not exist create 
    a new one and return it </para></listitem>
    </itemizedlist>
    </para>
    <para> The mechanism described above works well for graphs. However, in Tulip we are working with a hierarchy of graphs. 
Thus a special mechanism have been added in order to enable to share easily properties between graphs. This mechanism use
the fact that if a property exists in an ancestor of a graph, it can be use on the graph. This looks like an inheritance 
mechanism of properties between graphs. As in object oriented language, in Tulip, it is possible to inherit a property
or to have it defined locally. In order to facilitate the navigation/edition of the set of properties, a
set of function is accessible through the graph interface.
    <itemizedlist>
    <title>List of available operations</title>
    <listitem><para><methodname>Iterators * getInheritedProperties()</methodname> : return an iterator on all the inherited properties.</para></listitem>
    <listitem><para><methodname>bool existProperty(std::string)</methodname> : return true if the property exists (inherited or locally).</para></listitem>
    <listitem><para><methodname>Proxytype * getProperty(std::string)</methodname> : return the property (inherited or local) or if it does not exist create 
    a new one (locally) and return it </para></listitem>
    </itemizedlist>
    </para>
</sect1>

<sect1 id="code-exemples"><title>Examples of code</title>
    <sect2 id="code-exemples-graphs"><title>Graphs</title>
        <para></para>
    </sect2>

    <sect2 id="code-exemples-properties"><title>Properties</title>
        <para></para>
    </sect2>
</sect1>
</chapter>

<chapter id="opengl-library"><title>Tulip Open GL Library</title><para></para></chapter>

<chapter id="qt-library"><title>Tulip QT Library</title><para></para></chapter>

<chapter id="plugins-mechanism"><title>Plug-ins mechanism</title>
<para>Tulip has been built to be easily extensible. Therefore a mechanism of plug-ins has been set-up. It enables
to directly add new functionalities into the Tulip kernel. One must keep in mind that a plug-in have access to 
all the part of Tulip. Thus, one must write plug-ins very carefully to prevent memory leak and also 
errors. A bug in plug-in can result in a "core dump" in the software that uses it. To
enable the use of plug-ins, a program must call the initialization functions of the plug-ins. This function
parse all the Tulip plug-ins directory and load dynamically all the plug-ins and register them into 
a factory that will enables to access to it directly.</para>

<sect1 id="available-plugin"><title>Available plug-ins</title><para></para>
</sect1>

</chapter>

<chapter id="graph-format"><title>Tulip graph format</title>
    <para></para>
</chapter>

<chapter id="prog-guidelines"><title>Programming Guidelines</title>
    <!--======  GENERALITES   ========================================================    -->
    <sect1 id="generalites"><title>Generalities</title>
        <para>The presentation of a program indicates the quality of programming. This section relates to the common recommendations for the Tulip project. Each new programmer has to follow the expressed rules.</para>
        <para>In the header files, the programmer should write a headline containing : his name with personal (for students) email adress, the date of the last modifications, a reminder of the licence GPL and the references of the code (for example, an algorithm). Header files must include a construction that prevents multiple inclusion. The convention is an all uppercase construction of the file name, the h suffix and prefixed by <quote>Tulip_</quote>.</para>
        <para>The organisation of files must be comprehensible. New module leads to a new set of files :  a <filename>*.cpp</filename> and a <filename>*.h</filename> named with the name of the type. If the structure implicates that all methods are inline, the creation of a <filename>.cxx</filename> file is better than a <filename>.cpp</filename> file. The <filename>cxx</filename> should be included at the bottom of the header file. None implementation is in the header file. In the Tulip hiearchy, the cxx files are in a directory <quote>cxx</quote> in the header location. </para>
        <para>The indentation is an important part for a easy reading in a file and a best understanding. Code must be properly indented to show the syntactic structure of the program. It is useless to space out excessively the code. A conventionnal indentation is just necessary. None useless <keycap>TAB</keycap> or spaces. The <quote><symbol>{</symbol></quote> caracter for the opening of a method or a function must be at the end of the line, not in following line. Each new fitted block of program implies a new shift for the indentation.</para>
        
        <para>Each new module inserted in the Tulip library must be included in the namespace <emphasis>tlp</emphasis>. It is necessary in order to prevent eventually incompatibilities.</para>
        <para>Tulip is dependent of the Standard Template Library, <acronym>STL</acronym>. it exists two ways to use objects from it. In the <filename>.h</filename> or <filename>.cxx</filename> files, you should preface them with the std namespace (e.g. <code>std::string s;</code>). You will refer them with the fullname : namespace and class name. For the <filename>.cpp</filename> files, you can use the short name if you insert the line at the top of your document <code>using namespace std;</code>.
        </para>
     </sect1>
<!--=================================================================================    -->

<!--======  NAMMING   ===============================================================    -->
    <sect1 id="namming"><title>Namming conventions</title>
	<para> Programmer of Tulip has to follow some rules for choosing Type, Functions, or Variables names. Each names must be in English and choose to an easy understanding, descriptive and accurate. Each important word must be found in the name.
	    <itemizedlist><title>List of Rules</title>
		<listitem><para>Types (struct, class, ...) : Names must be in mixed case starting with upper case. Each word should have first letter in upper case. Don't use underscore to separate words</para></listitem>
		<listitem><para>Functions and Methods : Names must be in mixed case like for Types, but starting with lowercase. After the first one, each important word has first letter in upper case. Don't use underscore to separate words</para></listitem>
		<listitem><para>Variables : Names must be in lower case.</para></listitem>
		<listitem><para>Constants : Names must be in upper case.</para></listitem>
		<listitem><para>Macro and Enumeration constans : Names must be defined in upper case with an underscore between words.</para></listitem>
		<listitem><para>Namespaces : Names must be in lower case.</para></listitem>
	    </itemizedlist>

           The <emphasis>setter</emphasis> and <emphasis>getter</emphasis> must begin with the keyword <methodname>set</methodname> or <methodname>get</methodname>. All of the method or functions should begin with a verb for understanding its goal. The prefix of a boolean variables or methods should be <emphasis>is, can, has, should</emphasis> : <methodname>bool isValid(const edge e) const</methodname>, function specified if the edge is valid.
	</para>
    </sect1>
<!--=====================================================================================    -->

<!--======= COMMENTAIRES ================================================================    -->
    <sect1 id="commentaires"><title>Code Comments</title>
	<para>
	    All of the comments in the source and the header files must be written in the English language. Lots of comments is a simple way to leave a clear code for the next programmer who will take your work. A part of comments must be written with several rules to help the documentation of your work generating automatically with <emphasis>Doxygen</emphasis>. Choose a part of your comments to describe your work. See <xref linkend="doxygen"/>
	</para>
	<para>
	    Before a declaration of a class, you should write a little description to explain its role. The role, the prerequisites, the return values and the parameters should be written before the declaration of the function or method.
	    In the code, it is useless to comment each line because the comments are often a paraphrase of the code. It is just essential to write a comment for strong parts. 
	</para>
    </sect1>
    <!--===================================================================================    -->

    <!--======= INTEGRATION ================================================================    -->
    <sect1 id="integration"><title>Integration in Tulip project</title>
        <sect2 id="files-adds"><title>Files adds</title>
	   <para> To integrate a new module, set of types, in the Tulip project, you must to know which library is concerned : General library, OpenGL library, QT library, ... For each case, the procedure is the same. <filename>tulip/library/tulip-ogl/</filename> is the directory to intergate a library attached to the Opengl library. All of the <filename>cpp</filename> files are pasted in the <filename>src</filename> subdirectory, <filename>h</filename> files in <filename>include/tulip</filename> and <filename>cxx</filename> files in <filename>include/tulip/cxx</filename>. Some modifiactions of your code shoud be necessary. The inclusion of files of Tulip project (included your work) is made with &lt; and &gt; because the compiler knows the path. For Tulip, the header files is in a special directory : <programlisting>#include &lt;tulip/TheFile.h></programlisting>
	   Tulip uses automatically generation of <filename>Makefile</filename>. So, you have to modify two files in the directory of your library. <filename>include/Makefile.am</filename> is the first. You have to complete a variable containing all <filename>.h</filename> and <filename>.cxx</filename> files with your header files. The second one is <filename>src/Makefile.am</filename> and so, you complete the variable containing all <filename>.cpp</filename> files with your source files. After a new generation of an update of the makefiles, the next compilation include your work. The update of the makefiles is made with the command <methodname>./configure</methodname> with the options that you prefer.
           </para>
        </sect2>
        <sect2 id="build-sys"><title>Build system modifications </title>
            <sect3 id="presentation"><title>Presentation</title>
                <para> GNU has several tools used for the configuration of Tulip package. It modifies the makefile to adapt their to the distribution you have : the most important tools are <application>autoconf</application>, <application>automake</application> and <application>libtool</application>.</para>
                <para><application>Autoconf</application> is a tool of GNU producing shell scripts that automtically configure software packages to adapt to many kinds of UNIX systems. It is not the unique tool, it runs with others to solve all problems to making portable software. It generates configurations scripts. It checks for the presence of each feature that the software need. Autoconf requires <application>GNU M4</application> in order to generate the scripts. </para>
                <para>To this end, GNU has developed a set of integrated utilities to finish the job of <application>Autoconf</application>. Automake is the next in run. </para>
            </sect3>
            <sect3 id="some-rules"><title>Some Rules</title><para>The first and simple modification of the makefile is the one explained in the previous section : included new source files in your project.</para>
            <para><ulink url="http://www.amath.washington.edu/~lf/tutorials/autoconf/toolsmanual.html#SEC30">See Developing software with GNU : the GNU build system</ulink></para></sect3>
        </sect2>
    </sect1>
    <!--===================================================================================    -->
</chapter>


<chapter id="doc-guidelines"><title>Documentation Guidelines</title>
    <sect1 id="definitions"><title>Definitions</title>
	<orderedlist>
	<listitem id="docbook"><para>Docbook is a collection of standards and tools for technical publishing. A Docbook file is composed of SGML(<xref linkend="sgml"/>) tags and is also dependant of a Document Type Definition(<xref linkend="dtd"/>). Docbook has defined standard DTD that you can find in the docbook tools.</para></listitem>

	<listitem id="dtd"><para>DTD : Document Type Definition. The DTD defines the vocabulary of content elements that an author can use and how they relate to each other. For example, a book element can contain a title element, any number of para elements for paragraphs, and any number of chapter elements. </para></listitem>

	<listitem id="sgml"><para>SGML : Standard Generalized Markup Language</para></listitem>
    
        <listitem id="xsl"><para>XSL (Extensible Stylesheet Language) is a language of description used for the transformation of the sgml file into formatted ouput: XSL processors like xsltproc, saxon or xalan, ... do that.</para></listitem>

	</orderedlist>
    </sect1>
    <sect1 id="tools-install"><title>Tools installation</title>
        <sect2 id="duck-install"><title>Docbook XSL Stylesheet</title>
            <para> There is a great reference for installing tools : <ulink url="http://www.sagehill.net/docbookxsl/ToolsSetup.html#InstallDTD">Docbook XSL : the guide</ulink>.</para>
            <para>To write a manual using Docbook and the XSL stylesheets, we need three tools : 
            <itemizedlist>
            <listitem>
                <para>Docbook DTD</para>
            </listitem>
            <listitem><para>Docbook XSL stylesheets</para></listitem>
            <listitem><para>XSL processor</para></listitem>
            </itemizedlist>
            There are RPM (docbook-utils, docbook-style-xsl) and Debian (docbook-utils, docbook-xsl) packages for Linux systems, Fink packages for Mac systems, and Cygwin and other packages for Windows systems. If you need another solution, you can download the source package on oasis <ulink url="http://www.oasis-open.org/docbook/xml/">web site</ulink>, a <filename>.zip</filename> file. The Docbook XML DTD consists of a main file <filename>docbookx.dtd</filename> and several module files. You only need to reference the main file, and it will pull in the other module files to make up the complete DTD. The XSL files are cutted in several files too. <filename>chunk.xsl</filename> is used to generate a documentation with several pages and included a system of links <quote>HOME, UP, NEXT, PREV</quote>, <filename>docbook.xsl</filename> to make a unique page. The path of the xsl files is automatically found with catalog system. Docbook creates a file, <filename>/etc/xml/catalog</filename>, which contains all catalog references to resolving the path. For an URL adress of the DTD or the XSL file, it correspond to a located file for your file system.</para>
            <para> To install a compatible processor, show <xref linkend="duck-compil"/>. It explains how to use it too.</para>
        </sect2>
        <sect2 id="dox-install"><title>Doxygen</title>
            <para>It can already be in your distribution. If not, you can download it on the official web site. For distributions like Debian or Fedora Core, you can used : <cmdsynopsis><command>yum</command><arg><option>install</option> doxygen</arg></cmdsynopsis><cmdsynopsis><command>apt-get</command><arg><option>install</option> doxygen</arg></cmdsynopsis> For another solution, you can find source files and <application>CVS</application> repository in the web site of Doxygen.</para>
        </sect2>
    </sect1>
    <sect1 id="written"><title>Handwriting for the manuals</title>
    <para>Some works on the Tulip project lead to make a part of a handbook for developer or users. Docbook utilities are used to create them. 
	Docbook is an SGML document type definition (DTD). It is an standard that describes how markup languages are defined. SGML does not consist of particular tags or the rules for their usage. HTML is an example of a markup language defined in SGML. On the other hand, XML leads to take the place of SGML to alleviate compatibility problems with browser software. It's a new, easier version of the standard rules that govern the markup itself. To find all of the xml elements, you can see : <ulink url="http://www.docbook.org/tdg/en/html/part2.html">http://www.docbook.org/tdg/en/html/part2.html</ulink></para>

	<para>For each document, a set of SGML files is created. To help the editing of the handbook, it is possible to use general editors like kate, emacs, quanta. See <ulink  url="http://i18n.kde.org/doc/doc-primer/docbook-editors.html"> Docbook Editors</ulink>. To configure Kate, select <filename>Configure Kate</filename> -> <filename>Settings</filename> -> <filename>Configure Kate</filename>. Select the plugin item from the application tree and check the <filename>Kate XML Completion</filename>, and the <filename>Kate XML Validation</filename> boxes. </para>
    
        <para>The common files used for compilation are in a directory named <filename>common</filename>. It locates in <filename>docs</filename> of the Tulip directory.</para>

	<sect2 id="tricks"><title>Tricks for the beginning</title>
	    <para>
	    <programlistingco>
	    <areaspec>
		<area id="xml" coords='2'/> <area id="comments" coords='3'/><area id="doctype" coords='4'/>
            </areaspec>
<programlisting>
&lt;?xml version='1.0'?&gt;
<emphasis>&lt;!-- My first Docbook file --></emphasis>
&lt;!DOCTYPE book PUBLIC "-//OASIS//DTD Docbook XML V4.4//EN"
    "/usr/share/sgml/docbook/xml-dtd-4.4-1.0-27/docbookx.dtd"&gt;
	    </programlisting>
	    <calloutlist>
		<callout arearefs="xml"> <para>defined that it is a xml document version 1.0</para></callout>
		<callout arearefs="comments"> <para>the comments are writing between &lt; and &gt;</para></callout>
		<callout arearefs="doctype"> <para>DTD, Document Type Declaration</para> </callout>
	    </calloutlist>
	    </programlistingco>
            The identification of the DTD is used by the document to know which root element is. Here, <quote>OASIS</quote> is the owner, the declaration is <quote>DTD XML V4.4</quote> and the language is English <quote>EN</quote>. The keyword <quote>book</quote> specifies that the root element is <emphasis>book</emphasis>. An example of the structure of a Docbook file is like followed.
<programlisting>
&lt;!DOCTYPE book PUBLIC "-//OASIS//DTD Docbook V4.4//EN">
&lt;book> 
    &lt;bookinfo> 
	&lt;title>My First Book&lt;/title>

	&lt;author>&lt;firstname>Jean-Pierre&lt;/firstname>&lt;surname>DUPONT&lt;/surname>&lt;/author>
	&lt;copyright>&lt;year>2005&lt;/year>&lt;holder>Jean-Pierre DUPONT&lt;/holder>&lt;/copyright>
    &lt;/bookinfo>
    &lt;preface> ... &lt;/preface>
    &lt;chapter> ... &lt;/chapter>
    &lt;chapter> ... &lt;/chapter>
    &lt;chapter> ... &lt;/chapter>
    &lt;appendix> ... &lt;/appendix>
    &lt;appendix> ... &lt;/appendix>
    &lt;index> ... &lt;/index>
&lt;/book>
</programlisting></para>
        <sect3 id="valid"><title>Validation</title><para>
        The validity of a document is very difficult to detect, so we use a program to do that. A validating parser is a program that can read the DTD and determine whether the exact order of elements in the document is valid according to the DTD. </para>
        <para>To determinate if the XML code is valid, the program <application>meinproc</application> can be used with the option --check. It is the KDE-specific tools. <cmdsynopsis><command>meinproc</command><arg><option>--check</option> myfile.docbook</arg></cmdsynopsis>
        When there are errors in the document, <application> meinproc </application> detect the number line and display the form that it should be.
<screen>
index.docbook:485: element sect2: validity error : Element sect2 
content does not follow the DTD, expecting (sect2info? , (title , 
subtitle? , titleabbrev?) , (toc | lot | index | glossary | 
bibliography)* , (((calloutlist | glosslist | bibliolist | itemizedlist
| orderedlist | segmentedlist | simplelist | variablelist | caution |
important | note | tip | warning | literallayout | programlisting |
programlistingco | screen | screenco | screenshot | synopsis |
cmdsynopsis | funcsynopsis | classsynopsis | fieldsynopsis | 
constructorsynopsis | destructorsynopsis | methodsynopsis | formalpara
| para | simpara | address | blockquote | graphic | graphicco | 
mediaobject | mediaobjectco | informalequation | informalexample | 
informalfigure | informaltable | equation | example | figure | table |
msgset | procedure | sidebar | qandaset | task | anchor | bridgehead |
 remark | highlights | abstract | authorblurb | epigraph |indexterm | 
beginpage)+ , (refentry* | sect3* | simplesect*)) | refentry+ | sect3+ |
 simplesect+) , (toc | lot | index | glossary | bibliography)*), got (
refentry)
&lt;/sect2>
                   ^
make: *** [check] Erreur 1
</screen>
        An other solution to validate an XML and specialy a SGML document is the program <application>xmllint</application>. This program is a parser dependent of the library <emphasis>libxml2</emphasis>.
        <cmdsynopsis><command>xmllint</command><arg><option>--valid  --noout</option> myfile.docbook</arg></cmdsynopsis>
        The description of the errors has the same display.</para>

        <para>It exists several attempts to produce an print or web publishing. Recently, the XML workgroup has made a standard Extensible Style Language (XSL). DSSSL is an other possibility, but we use the XSL stylesheet for the Tulip project. This stylesheet is specified at that compilation with an XSL processor for the XSL transformations.</para>
        </sect3>
        <sect3 id="duck-compil"><title>Compilation</title>
            <para>
                To transform an docbook file to an HTML formatted output, we need a stylesheet file. An XSL stylesheet describes the formatting that can be applied to XML files using an XSL processor. Currently, there are three to do XSL Transform processing with the recommendations of XSL : saxon (<ulink url="http://saxon.sourceforge.net/"/>), xalan (<ulink url="http://xml.apache.org/xalan-j/"/>), and xsltproc (<ulink url="http://xmlsoft.org/XSLT/xsltproc2.html"/>).</para>

                <para><application>Saxon</application> is a free processor written in Java, so it can be run on any operating system with a modern Java interpreter. To install it, you have to download on sourceforge the last release 6.5.4. for debian, it exists a deb package. This is the full version that implements the XSLT 1.0 standard. It runs on Java system and provides opportunities for extensions. For Windows, it exists the <application>Instant Saxon</application> a precompiled version that runs only on Microsoft Windows. Saxon is distributed as a zip package. You have to unzip it into a suitable location. It gives three <filename>.jar</filename> files ; <filename>saxon.jar</filename> contains the XSLT processor. In according to the location, you have to update your CLASSPATH. You need to include the full path to the necessary .jar files in the CLASSPATH environment variable. To update it :
<screen>
CLASSPATH=$CLASSPATH:/usr/saxon/saxon.jar:\
/usr/docbook-xsl/extensions/saxon653.jar
export CLASSPATH
</screen>
                If your CLASSPATH is incorrect, you get an error message about <methodname>NoClassDefFoundError</methodname>. To generalize it, you have to change your <filename>.bashrc</filename> or <filename>.bash_profile</filename>. In this example, a second package is included : <filename>/usr/docbook-xsl/extensions/saxon653.jar</filename>, in Fedora Core 4, it is located in <filename>/usr/share/sgml/docbook/xsl-stylesheets/extensions/</filename>. It contains the implementation of the extensions of XSL Transformations. This extensions are necessary for the manage of certain tags and are included in the docbook tools. The general syntax for compilation is like followed :

                <cmdsynopsis><command>java com.icl.saxon.StyleSheet </command>
                        <arg><option>options</option></arg>
                        <arg>file.docbook</arg>
                        <arg>file.xsl</arg>
                        <arg><option>param=value</option></arg>
                </cmdsynopsis>

                However, <application>Xalan</application> is XSLT stylesheet processor, in Java and C++ from Apach XML Project. It is an another solution to compile the docbook files. Then, <application>Xsltproc</application> is the xslt c library for gnome. This program is a way to use the library <emphasis>libxslt</emphasis> with a command line tool for applying XSLT stylesheets to XML documents. This application runs quickly but does not include the implementation of the extensions.</para>
        </sect3>
	</sect2>
        <sect2 id="duck-faq"><title>Docbook FAQ</title>
            <qandaset>
                <qandaentry>
                    <question><para>how to separate the work in several files ?</para></question>
                    <answer><para>
                    The first solution to write a part of a handbook is to complete the main document. To avoid that several persons work on the same file, it exists a solution to cut the docbook file. You can write a section or a chapter and you just have to include your part in the main file. To create a valid file for the compiler, you shoud modify the head of a docbook file and specify the kind of document you do. For a chapter, your file is like followed :
<programlisting>
&lt;!DOCTYPE chapter PUBLIC "-//OASIS//DTD Docbook XML V4.4//EN">
&lt;chapter> 
	&lt;title>My personal Chapter&lt;/title>
        &lt;sect1> ... &lt;/sect1>
&lt;/chapter>
</programlisting>
           The identification gives the kind of file you write. For including your work, you just have to complete the declaration of the main file and insert a special tag located at the place that you want the inclusion. Don't forget to erase the declaration of your work. The file must begin with the markup <quote>chapter</quote>.
<programlisting>
&lt;!DOCTYPE book PUBLIC "-//OASIS//DTD Docbook V4.4//EN" [
  &lt;!ENTITY myPersonalFile SYSTEM "myFile.xml"
]&gt;
&lt;book>
...
&lt;/chapter>
&#038;myPersonalFile;
&lt;chapter>
...
</programlisting>
                      </para></answer>
                </qandaentry>
                <qandaentry>
                    <question><para>How to insert a figure ?</para></question>
                    <answer><para>the element uses for the insert of a figure is <quote>&lt;figure></quote>. It enable the numerotation of the figures. Warning, the width of the figures should not exceed a certain value to avoid that it is truncated in the pdf transform. You can specify a title and other parameter in the limits of the DTD. 
<programlisting>
&lt;figure> &lt;title>Screenshot of the result&lt;/title>&lt;graphic fileref="doxygen-ex.png"/>&lt;/figure></programlisting></para></answer>
                </qandaentry>
                <qandaentry>
                    <question><para>How to make annontation in a program listing ?</para></question>
                    <answer><para>See <ulink url="http://www.sagehill.net/docbookxsl/AnnotateListing.html#Callouts">DocBook XSL : the complete guide</ulink></para></answer>
                </qandaentry>
            </qandaset>
        </sect2>
    </sect1>
    <sect1 id="doxygen"><title>Code documentation</title>
        <sect2 id="presentation_dox"><title>Presentation</title>
	<para><application>Doxygen</application> is a documentation system for several languages like C++. It can generate an on-line documentation browser (in HTML), a set of manpages, an off-line reference manual (in LaTeX) and/or others from the set of documented source files of your project. This kind of documentation is a necessary tool for developers to find informations about the code. It is not a way to explain how it is imagined but which possibilities you have. It is available for several distributions like Fedora Core, Debian, Gentoo and others,..  Windows, MacOs and Sun Solaris too.
	</para>
	<para>To create your first <application>Doxygen</application> documentation, you need a config file .cfg or .doxygen. To generate it :
	<cmdsynopsis><command>doxygen</command><arg><option>-g</option> myfile.doxygen</arg></cmdsynopsis>
        The file contains the options you can choose for the documentation generation. Comments indicates how to use this variables. The INPUT variable contains the files or directories to find the source files. When you have set all tags with good values, you can generate the documentation. <application>Doxygen</application> checks the source files to extract the informations in special comments and tags. See this page for the informations about the variables : <ulink url="http://www.stack.nl/~dimitri/doxygen/config.html">http://www.stack.nl/~dimitri/doxygen/config.html</ulink>. To create it :
	<cmdsynopsis><command>doxygen</command><arg>myfile.doxygen</arg></cmdsynopsis>
        By default, it creates directories : html, latex, and/or man, ...
	</para>
        <para>For the <application>Tulip</application> project, the configuration files are still created and are located in the subdirectory of the special library, for example in <filename>$TULIPDIR/docs/doxygen/tulip-lib</filename>.</para>
        </sect2>
	<sect2 id="dx-comments"><title>Developer comments</title>
	    <para>The code documentation, generated by <application>Doxygen</application> is completely dependant of the developer comments. It is important that developers follow the grammar rules. </para>
	    <para>So the blocks of documentation in the sources files are the C++ comment blocks. For each item of code, there are two types of descriptions, which together form the documentation : a brief description and detailed description. A detail description is used to explain generously the existence of an item.
	    <screen>
/**
* detailed description
*/

or 

/*!
* detailed description
*/

or 

/*!
 detailed description
*/

or others ....
		</screen>
	    To make a brief description, you can use the command <methodname>\brief</methodname>. This command ends at the end of a paragraph, so the detailed description follows after an empty line. An other option is to use a special C++ style comment which does not span more than one line.
<screen>
/*! \brief Brief description.............
*         ...............
*
*  Detailed description
*/

or 

/// Brief description 
/** Detailed description. */

or 

//! Brief descripion.

//! Detailed description 
//! starts here.

or others ....
	    </screen>
	    For more details, the web site of <ulink url="http://www.doxygen.org/docblocks.html">Doxygen</ulink> explains it. 
	    In general, the comments must be before the declaration or definition of a type, a function or a member. If you want to putting the documention after, you have to add a marker &lt;. Note that you can place your comment at other places using some tags like \class, \union, \fn, \var, ... or @class, @union, @fn, @var, ...
	    </para>
	    <para>
	    It exists several tags to help you for commenting and writing a description : all of it begin with a backflash <symbol>\</symbol> or an at-sign<symbol>@</symbol>.
	    <itemizedlist>
		<listitem><para>@author, <emphasis>name of the author</emphasis>. </para></listitem>
		<listitem><para>@param, <emphasis>to write a special comment on a parameter of a method or function</emphasis> </para></listitem>
		<listitem><para>@see, <emphasis>to make a reference to an other object or function</emphasis></para></listitem>
		<listitem><para>@return, <emphasis>to indicate the exit of a function</emphasis></para></listitem>
		<listitem><para>@date, <emphasis>date of creation</emphasis></para></listitem>
		<listitem><para>@note, <emphasis>desribe a role</emphasis></para></listitem>
		<listitem><para>@attention, <emphasis>write a caution</emphasis></para></listitem>
		<listitem><para>@warning</para></listitem>
		<listitem><para>@pre, <emphasis>write a prerequisite</emphasis></para></listitem>
		<listitem><para>@remark</para></listitem>
	    </itemizedlist>
            The complete list is on this <ulink url="http://www.stack.nl/~dimitri/doxygen/commands.html">page</ulink> in the <application>Doxygen</application> web site.
	    </para>

            <para><example><title>Doxygen : A simple source file</title>
<para><programlisting>
// ... comments not include  ...
///  A example of class : MyClass. 
/**
    a more detail class description :
    \author Me
    \date 29/07/2005
*/
#include &lt;string>
class MyClass
{


    /* ... comments not include ... */
    public:
        /** the constructor of the class */

        /**  the detail description of the constructor. */
        MyClass(){i=0;}
 
        //! A destructor.
        ~MyClass(){}

        /// drawing of a string
        /**
            \param s the string to display
            \return there is no return
            @sa MyClass(), ~MyClass()
        */
        void draw(const char *s="Hello World");

        /* exemple of doc comments not before the declaration */
        unsigned int getI(){return i;} /**&lt;@return the number the value of i */
    private:
        unsigned int i;


    /** @var i
        @brief, you can put the comments where you want with the special tags */
};
</programlisting>

</para></example></para>

            <para>To update the Documentation of Tulip, you just have to use the makefile and so write : <filename>make docs</filename>.</para>
	</sect2>

        <sect2 id="dow-faqs"><title>Doxygen FAQ</title>
	<qandaset>
	    <qandaentry>
		<question><para>How to insert a block of code ?</para></question>
		<answer><para> To illustrate your documentation, you can insert a block of code in a description between <quote>\code</quote> and <quote>\endcode</quote>. This code is written in the documentation with highlighting syntax. </para></answer>
	    </qandaentry>
            <qandaentry>
		<question><para>How to force an end of line ?</para></question>
		<answer><para>Use the tag <methodname>\n</methodname>.</para></answer>
	    </qandaentry>
            <qandaentry>
		<question><para>How to make doxygen ignore code fragment ?</para></question>
		<answer><para>It exists two ways to resolve this questions. The first one is to use the tags <quote>\cond</quote> and <quote>\endcond</quote> to skip the internal code. The second way is to use the preprocessor of Doxygen. In the configuration file, you specify the MACRO and you verify if the value of PREPROCESSING is to yes. Then, you set PREDEFINED to DOXYGEN_SHOULD_SKIP_THIS.

<programlisting>
#ifndef DOXYGEN_SHOULD_SKIP_THIS

 /* code that must be skipped by Doxygen */

#endif /* DOXYGEN_SHOULD_SKIP_THIS */
</programlisting>
</para></answer>
	    </qandaentry>
            <qandaentry>
                    <question><para>How to insert a equation ?</para></question>
                    <answer><para>See the <ulink url="http://www.stack.nl/~dimitri/doxygen/formulas.html">Doxygen web site</ulink></para><para>Doxygen allos you to put Latex formulas in the ouput (just for HTML and latex format). Three ways are avaible. If you want to include formulas in-text, you have to put formulas between a pair of <quote>\f$</quote>
                    <screen>
\f$ AB = \sqrt{BC^2 + CA^2} \f$
                    </screen> 
                    The second way is for a centerd display on a seperate line. These formulas should be put between <quote>\f[</quote> and <quote>\f]</quote> commands.</para>
                    <para>The third way is to used formulas or other latex elements that are not in a math environment. It can be specified using \f{<emphasis>environment</emphasis>}, where <emphasis>environment</emphasis> is the latex environment, the corresponding end commands is <quote>\f}</quote></para></answer>
                </qandaentry>
	</qandaset>
        </sect2>
    </sect1>
    <sect1 id="docs-ref"><title>References</title>
        <para>Docbook XSL : the complete Guide <ulink url="http://www.sagehill.net/docbookxsl/index.html">http://www.sagehill.net/docbookxsl/index.html</ulink></para>

        <para>The Duck Book - <ulink url="http://www.oreilly.com/catalog/docbook/chapter/book/docbook.html">Docbook : the Definitive Guide </ulink></para>

        <para>The KDE documentation primer : recommandations to write correctly in Docbook - <ulink  url="http://i18n.kde.org/doc/doc-primer/index.html">http://i18n.kde.org/doc/doc-primer/index.html</ulink></para>

         <para>Doxygen web site - <ulink url="http://www.docbook.org/tdg/en/html/part2.html">http://www.docbook.org/tdg/en/html/part2.html </ulink></para>
    </sect1>
</chapter>
</book>
