<?xml version='1.0'?>
<!--<?xml-stylesheet href="../common/tulip-default.css" type="text/css"?>-->
<!DOCTYPE book PUBLIC "-//OASIS//DTD Docbook XML V4.4//EN" "/usr/share/sgml/docbook/xml-dtd-4.4-1.0-27/docbookx.dtd">

<!--<!DOCTYPE book PUBLIC "-//OASIS//DTD Docbook XML V4.1.2//EN"
	"../common/tulip-dtd.dtd">-->

<book><bookinfo><title>Tulip Developer Handbook</title></bookinfo>

<chapter id="introduction"><title>Introduction</title><para></para></chapter>
<chapter id="installation"><title>Installation</title><para></para></chapter>
<chapter id="data-structure"><title>Data Structure</title>
<para>Efficient visualization of graphs implies to manipulate the structure of 
the graph but also to extract part of this structure. Moreover, if one 
wants to visualize graphs and to use graphs for data analysis, one must
take into account the values associated to the element (node or edge) of the 
graph. One other central point in a visualization system is to provide a 
way to compute parameters based on the intrinsic (or extrinsic) parameters
of a given graph. We call intrinsic parameters those calculated by using the
structure of the graph and extrinsic parameters those calculated using external
information. For instance, if we consider a file system, the size of a file is
an extrinsic parameter and the number of file in a directory is an intrinsic parameter 
because in can be computed by analyzing the structure of the tree representing the file system.  
</para>
<para>
This chapter describes the Tulip data structure that takes into account all the requirement
of a graph visualization system. For each part we describe precisely the general principle and
then we give several examples explaining how it can be done using the Tulip library.
</para>

<sect1 id="graphs"><title>Graphs</title>
    <para>The core of the Tulip library provides an interface for the manipulation of graphs. This interface enables
to access and to modify the structure of a graph. The objective of this library is to be the more general 
as possible and thus this interface enables to manipulate a general class of graphs called directed pseudo-graph. 
In a pseudo graph, it can exists several edges between two nodes and it can exists several loops. A loop is an
edge that links a node to itself. Furthermore, the link are directed, thus an edge linking a node u to a node v is
different from an edge linking a node v to a node u. 
    </para>
    <para>
    Using of pseudo-graph implies that it can exist two edge between a node u and a node v. Thus, it is not possible to
distinguish an edge using only its source and its target (u,v). To enable such a distinction, all the element in Tulip
are entities (objects). Thus, even if two edges have the same source and the same target they are different.    
    </para>
    <para>
Another important point to consider is that it is not possible to access to the structure of a graph through elements 
(node or edge). Thus, all operations on the graph structure must be done by querying the graph. For instance, if one
wants to know the source of an edge e of graph G, one must ask to G what is the source of e. This characteristic makes
the use of the library a little bit less intuitive but, it enables to store entities using the minimum space and to 
share them between sub-graphs. When using the Tulip data structure one must always keep in mind that building a container 
of elements corresponds to store a container of integers in memory. For instance, a std::vector&lt;node&gt; is 
equivalent to a std::vector&lt;unsigned int&gt;. 
    </para>
    <para>
The library support access and modification of the graph structure. The access to the structure are made by using iterators,
one very important point is that the iterator are not persistent. Thus, if one modify the graph structure all the iterators
on the graph structure can be invalid. This property enables to prevent from cloning the data structure and thus enables 
better access to it. For ease of use, Tulip includes mechanism that enables to transform an iterator into stable iterator,
one must keep in mind that it corresponds to clone the data structure and thus, it should be use only if it is necessary.
    </para>
    <para>
If one use Tulip only for the manipulation of one graph (no hierarchy), the list of available operations on the 
graph is given afterward. In the next section we will enhance the set of operations and the actions that they perform 
in order to manage a hierarchy of sub graphs
    <itemizedlist>
    <title>List of available modification operations</title>
    <listitem><para><methodname>node addNode()</methodname> : it enables to create a new node in the graph.</para></listitem>
    <listitem><para>    
        <methodname>edge addEdge(node,node)</methodname> : it enables to create a new edge in the graph. </para></listitem>
    <listitem><para><methodname>void delNode(node)</methodname> : it enables to delete a node in the graph.</para></listitem>
    <listitem><para><methodname>void delEdge(edge)</methodname> : it enables to delete an edge in the graph.</para></listitem>
    <listitem><para><methodname>void reverse(edge)</methodname> : it enables to reverse an edge (swap source and target).</para></listitem>
    </itemizedlist>
    <itemizedlist>
    <title>List of available access operations</title>
    <listitem><para><methodname>unsigned int deg(node)</methodname> : returns the degree of a node.</para></listitem>
    <listitem><para><methodname>unsigned int indeg(node)</methodname> : returns the in degree of a node.</para></listitem>
    <listitem><para><methodname>unsigned int outdeg(node)</methodname> : returns the out degree of a node.</para></listitem>
    <listitem><para><methodname>node source(edge)</methodname> : it returns the source of an edge.</para></listitem>
    <listitem><para><methodname>node target(edge)</methodname> : it returns the target of an edge.</para></listitem>
    <listitem><para><methodname>void opposite(edge,node)</methodname> : it enables to obtain the opposite of a node of an edge.</para></listitem>
    <listitem><para><methodname>Iterator * getInNodes(node)</methodname> : returns an iterator on the ancestors of a node.</para></listitem>
    <listitem><para><methodname>Iterator * getOutNodes(node)</methodname> : returns an iterator on the successors of a node.</para></listitem>
    <listitem><para><methodname>Iterator * getInOutNodes(node)</methodname> : returns an iterator on the neighborhood of a node.</para></listitem>
    <listitem><para><methodname>Iterator * getInEdges(node)</methodname> : returns an iterator on the ancestors of a node.</para></listitem>
    <listitem><para><methodname>Iterator * getOutEdges(node)</methodname> : returns an iterator on the successors of a node.</para></listitem>
    <listitem><para><methodname>Iterator * getInOutEdges(node)</methodname> : returns an iterator on the neighborhood of a node.</para></listitem>
    </itemizedlist>
    </para>
</sect1>

<sect1 id="hierarchy-graphs"><title>Hierarchy of graphs</title>
    <para> The Tulip library integrates the management of sub graphs. By definition a sub graph G' of a graph G is part of 
the elements of G such that G' is a graph. This implies that all sources and target of the edges of G' are in G'. 
Thus a sub graph can be manipulated exactly like a graph and so in Tulip one will only manipulates graphs that
we call SuperGraph because they could be or not sub graphs. As a sub graph is a graph one can need to obtain 
a sub graph of this sub graph and so on. Such an operation consists in building of a hierarchy of graphs. In this 
hierarchy if a graph G" is a descendant of a graph G, G" is a sub graph of G.
    </para>
    <para> One of the strong point of Tulip is to ensure efficiently that all elements are shared between graphs in a hierarchy
of graph. Thus, if a node n is element of a graph G and of a graph G' the entity n is the same in both graphs. Off course,
the information about the entity can changed between graphs. For instance, the degree of n can be different according to
the graph that we manipulate.
    </para>
    <para> One of the other feature in Tulip is that the sub graph relation in the hierarchy is preserved when one
makes modification of a graph. This requirement implies some change on the modification operations described above.
If one add a node in a graph, this node is automatically added to all the ancestor of this graph. If one delete a
node, this node is automatically deleted in all the descendant of the graph. If one reverse an edge, this edge is 
automatically reversed in all the hierarchy of graphs.
    </para>
    <para> In order to manipulate a hierarchy of graphs, a set of functions have been added to graph function introduced
above. This function enables to navigate in the hierarchy and also to modify the hierarchy of graphs. As for the
graph structure the access to the hierarchy structure is done by using iterators. One should remember that iterators
are not persistent and thus, if the hierarchy is modified, the iterators are invalid.
    <itemizedlist>
    <title>List of available modification operations</title>
    <listitem><para><methodname>SuperGraph *addSubGraph()</methodname> : return an empty sub graph of this graph.</para></listitem>
    <listitem><para><methodname>SuperGraph *delSubGraph(SuperGraph *)</methodname> : delete a sub graph, the descendant of this sub graph 
    continue to be sub graphs of the graph.</para></listitem>
    <listitem><para><methodname>SuperGraph *delAllSubGraph(SuperGraph *)</methodname> : delete a sub graph and all its descendant.</para></listitem>
    <listitem><para><methodname>edge addEdge(edge)</methodname> : add an edge element of another graph in the hierarchy.</para></listitem>
    <listitem><para><methodname>void addNode(node)</methodname> : add a node element of another graph in the hierarchy.</para></listitem>
    </itemizedlist>
    <itemizedlist>
    <title>List of available access operations</title>
    <listitem><para><methodname>Iterator * getSubGraphs()</methodname> : returns an iterator on the sub graphs.</para></listitem>
    <listitem><para><methodname>SuperGraph * getFather()</methodname> : returns the ancestor of the graph if the graph haven't got
    ancestor, it returns itself.</para></listitem>
    </itemizedlist>
    </para>
</sect1>

<sect1 id="attributes"><title>Attributes</title><para></para></sect1>

<sect1 id="properties"><title>Properties</title>
    <para> The Tulip property enables to store attribute on the elements of a graph. In Tulip we call it Property in 
order to prevent confusion with the graph attribute. Thus, the properties are for the elements and attributes are
for the graphs. The main idea in Tulip is that a property is always define for all kind (node and edge) of elements
in the graph. Thus we can always query for the value of an edge or a node to a property.
    </para>
    <para> As for the graph structure, to access the value of an elements one must query a property. This characteristic makes
the use of the library a little bit less intuitive but, it enables to store efficiently the properties. 
    </para>
    <para>
In general properties
can be seen as an associative table where you can set or get the value of an element. In order to prevent having a lot of cast 
in the code all the properties have type and thus there is no need to cast your result when you query a property. The standard
operation of a property are given below :
    <itemizedlist>
    <title>List of available modification operations</title>
    <listitem><para><methodname>void setNodeValue(node,TYPE)</methodname> : set the value of a node.</para></listitem>
    <listitem><para><methodname>void setAllNodeValue(TYPE)</methodname> : set the value of all nodes.</para></listitem>
    <listitem><para><methodname>void setEdgeValue(edge,TYPE)</methodname> : set the value of an edge.</para></listitem>
    <listitem><para><methodname>void setAllEdgeValue(TYPE)</methodname> : set the value of all edges.</para></listitem>
    </itemizedlist>
    <itemizedlist>
    <title>List of available access operations</title>
    <listitem><para><methodname>TYPE getNodeValue(node)</methodname> : return the value of a node.</para></listitem>
    <listitem><para><methodname>TYPE getEdgeValue(edge)</methodname> : return the value of an edge.</para></listitem>
    </itemizedlist>
    </para>
    <para> For each kind of properties it exists a specific implementation (inheritance) that enables to obtain
    specific operations (see developer documentation) depending of the Type. For instance, it is possible to obtain 
    the maximum value of a property if it a double. 
    </para>
    <para> One of the most important things is to know how to create a property or to access to an existing property
in the graph. To do this a graph includes a set of functions that enables to obtain/create/delete a Property. Because
the C++ signature of function does not include the TYPE of the returned argument, the syntax for this call is not 
very simple. For instance, if one wants to obtain a property containing double (called MetricProxy in Tulip) one must use
the following syntax : <methodname> MetricProxy *metric=graph->getProperty&lt;MetricProxy&gt;("name of the property");</methodname>
In the graph each properties are identified by their name which a std::string, when one ask for a property the type of this 
property is checked using the run time type interrogation mechanism of the C++. Warning, this test is only done when one 
compile its sources in DEBUG mode (default mode). In order to facilitate the navigation/edition of the set of properties, a
set of function is accessible through the graph interface.
    <itemizedlist>
    <title>List of available operations</title>
    <listitem><para><methodname>Iterators * getLocalProperties()</methodname> : return an iterator on all existing properties.</para></listitem>
    <listitem><para><methodname>void delLocalProperty(std::string)</methodname> : delete a property.</para></listitem>
    <listitem><para><methodname>bool existLocalProperty(std::string)</methodname> : return true if the property exists.</para></listitem>
    <listitem><para><methodname>Proxytype * getLocalProperty (std::string)</methodname> : return the property or if it does not exist create 
    a new one and return it </para></listitem>
    </itemizedlist>
    </para>
    <para> The mechanism described above works well for graphs. However, in Tulip we are working with a hierarchy of graphs. 
Thus a special mechanism have been added in order to enable to share easily properties between graphs. This mechanism use
the fact that if a property exists in an ancestor of a graph, it can be use on the graph. This looks like an inheritance 
mechanism of properties between graphs. As in object oriented language, in Tulip, it is possible to inherit a property
or to have it defined locally. In order to facilitate the navigation/edition of the set of properties, a
set of function is accessible through the graph interface.
    <itemizedlist>
    <title>List of available operations</title>
    <listitem><para><methodname>Iterators * getInheritedProperties()</methodname> : return an iterator on all the inherited properties.</para></listitem>
    <listitem><para><methodname>bool existProperty(std::string)</methodname> : return true if the property exists (inherited or locally).</para></listitem>
    <listitem><para><methodname>Proxytype * getProperty(std::string)</methodname> : return the property (inherited or local) or if it does not exist create 
    a new one (locally) and return it </para></listitem>
    </itemizedlist>
    </para>
</sect1>

<sect1 id="code-exemples"><title>Examples of code</title>
    <sect2 id="code-exemples-graphs"><title>Graphs</title>
        <para></para>
    </sect2>

    <sect2 id="code-exemples-properties"><title>Properties</title>
        <para></para>
    </sect2>
</sect1>
</chapter>

<chapter id="opengl-library"><title>Tulip Open GL Library</title><para></para></chapter>

<chapter id="qt-library"><title>Tulip QT Library</title><para></para></chapter>

<chapter id="plugins-mechanism"><title>Plug-ins mechanism</title>
<para>Tulip has been built to be easily extensible. Therefore a mechanism of plug-ins has been set-up. It enables
to directly add new functionalities into the Tulip kernel. One must keep in mind that a plug-in have access to 
all the part of Tulip. Thus, one must write plug-ins very carefully to prevent memory leak and also 
errors. A bug in plug-in can result in a "core dump" in the software that uses it. To
enable the use of plug-ins, a program must call the initialization functions of the plug-ins. This function
parse all the Tulip plug-ins directory and load dynamically all the plug-ins and register them into 
a factory that will enables to access to it directly.</para>

<sect1 id="available-plugin"><title>Available plug-ins</title><para></para>
</sect1>

</chapter>

<chapter id="graph-format"><title>Tulip graph format</title><para></para>
</chapter>

<chapter id="prog-guidelines"><title>Programming Guidelines</title>
    <!--======  GENERALITES   ========================================================    -->
    <sect1 id="generalites"><title>Generalities</title>
        <para>The presentation of a program indicates the quality of programming. This section relates to the common recommendations for the Tulip project. Each new programmer has to follow the expressed rules.</para>
        <para>In the header files, the programmer should write a headline containing : his name with personal (for students) email adress, the date of the last modifications, a reminder of the licence GPL and the references of the code (for example, an algorithm).</para>
        <para>The organisation of files must be comprehensible. New module leads to a new set of files :  a <filename>*.cpp</filename> and a <filename>*.h</filename> named with the name of the type. If the structure implicates that all methods are inline, the creation of a <filename>.cxx</filename> file is better than a <filename>.cpp</filename> file. At the bottom of the header file, the <filename>cxx</filename> is included. None implementation is in the header file. In the Tulip hiearchy, the cxx files are in a directory <quote>cxx</quote> in the header location. Then, the indentation is an important part for a easy reading in a file and a best understanding. It is useless to space out excessively the code, just an conventionnal indentation is necessary. </para>
        
        <para>Each new module inserted in the Tulip library must be included in the namespace <emphasis>tlp</emphasis>. It is necessary in order to prevent eventually incompatibilities.</para>
        <para>Tulip is dependent of the Standard Template Library, <acronym>STL</acronym>. it exists two ways to use objects from it. In the <filename>.h</filename> or <filename>.cxx</filename> files, you should preface them with the std namespace (e.g. <code>std::string s;</code>). You will refer them with the fullname : namespace and class name. For the <filename>.cpp</filename> files, you can use the short name if you insert the line at the top of your document <code>using namespace std;</code>.
        </para>
     </sect1>
<!--=================================================================================    -->

<!--======  NAMMING   ===============================================================    -->
    <sect1 id="namming"><title>Namming conventions</title>
	<para> In the listings, programmer has their rules for choosing Type, Functions, or Variables names. Each names must be in English and choose to an easy understanding. Each important word must be found in the name 
	    <itemizedlist><title>List of Rules</title>
		<listitem><para>Types (struct, class, ...) : Names must be in mixed case starting with upper case. Each word should have first letter in upper case. Don't use underscore to separate words</para></listitem>
		<listitem><para>Functions and Methods : Names must be in mixed case like for Types, but starting with lowercase. After the first one, each important word has first letter in upper case. Don't use underscore to separate words</para></listitem>
		<listitem><para>Variables : Names must be in lower case.</para></listitem>
		<listitem><para>Constants : Names must be in upper case.</para></listitem>
		<listitem><para>Macro : Names must be defined in upper case with an underscore between words.</para></listitem>
		<listitem><para>Namespaces : Names must be in lower case.</para></listitem>
	    </itemizedlist>
	</para>
    </sect1>
<!--=====================================================================================    -->

<!--======= COMMENTAIRES ================================================================    -->
    <sect1 id="commentaires"><title>Code Comments</title>
	<para>
	    All of the comments in the source and the header files must be written in the English language. Lots of comments is a simple way to leave a clear code for the next programmer who will take your work. A part of comments must be written with several rules to help the documentation of your work generating automatically with <emphasis>Doxygen</emphasis>. Choose a part of your comments to describe your work. See <xref linkend="doxygen"/>
	</para>
	<para>
	    Before a declaration of a class, you should write a little description to explain its role. The role, the prerequisites, the return values and the parameters should be written before the declaration of the function or method.
	    In the code, it is useless to comment each line beacause the comments are often a paraphrase of the code. It is just essential to write a comment for strong parts. 
	</para>
    </sect1>
    <!--===================================================================================    -->

    <!--======= INTEGRATION ================================================================    -->
    <sect1 id="integration"><title>Code Integration</title>
	<para> To integrate a new module, set of types, in the Tulip project. you must to know which library is concerned : General library, OpenGl library, QT library, ... For each case, the procedure is the same. <filename>tulip/library/tulip-ogl/</filename> is the directory to intergate a library attached to the Opengl library. All of the <filename>cpp</filename> files are pasted in the <filename>src</filename> subdirectory, <filename>h</filename> files in <filename>include/tulip</filename> and <filename>cxx</filename> files in <filename>include/tulip/cxx</filename>. Some modifiactions of your code shoud be necessary. The inclusion of files of Tulip project (included your work) is made with &lt; and &gt; because the compiler knows the path. For Tulip, the header files is in a special directory : <programlisting>#include &lt;tulip/TheFile.h></programlisting>
	Tulip uses automatically generation of <filename>Makefile</filename>. So, you have to modify two files in the directory of your library. <filename>include/Makefile.am</filename> is the first. You have to complete a variable containing all <filename>.h</filename> and <filename>.cxx</filename> files with your header files. The second one is <filename>src/Makefile.am</filename> and so, you complete the variable containing all <filename>.cpp</filename> files with your source files. The next compilation include your work.
    </para>
    </sect1>
    <!--===================================================================================    -->
</chapter>


<chapter id="doc-guidelines"><title>Documentation Guidelines</title>
    <sect1 id="definitions"><title>Definitions</title>
	<orderedlist>
	<listitem id="docbook"><para>DocBook is a collection of standards and tools for technical publishing. A DocBook file is composed of SGML(<xref linkend="sgml"/>) tags and is also a DTD(<xref linkend="dtd"/>). See <ulink url="http://www.oreilly.com/catalog/docbook/chapter/book/docbook.html">the Duck book</ulink> for valid tags and all of the informations about docbook.</para></listitem>

	<listitem id="dxsl"><para><ulink url="http://www.sagehill.net/docbookxsl/index.html"> DocBook XSL : the complete Guide</ulink></para></listitem>

	<listitem id="dtd"><para>DTD : Document Type Definition. The DTD defines the vocabulary of content elements that an author can use and how they relate to each other. For example, a book element can contain a title element, any number of para elements for paragraphs, and any number of chapter elements. </para></listitem>

	<listitem id="meinproc"><para>meinproc is the KDE translator for XML</para></listitem>

        <listitem id="nsgmls"><para>nsgmls, a SGML parser</para></listitem>

	<listitem id="saxon"><para>Saxon is a free processor written in Java, so it can be run on any operating system with a modern Java interpreter.</para></listitem>

	<listitem id="sgml"><para>SGML : Standard Generalized Markup Language</para></listitem>

	<listitem id="xalan"><para>Xalan is XSLT stylesheet processor, in Java and C++ from Apach XML Project.</para></listitem>
    
	<listitem id="xsl"><para>XSL (Extensible Stylesheet Language) processor is the software that transforms an XML file into formatted output : xlstproc, saxon, xalan</para></listitem>

	<listitem id="xsl-fo"><para>XSL-FO processors are really typesetting engines. It generates a PDF or PostScript file.</para></listitem>

	<listitem id="xslt"><para>XSLT (XSL Transformations) is a language used to transform XML document into other XML documents. For reference information, see the W3C Recommendation <ulink url="http://www.w3.org/TR/xslt.html">http://www.w3.org/TR/xslt.html.</ulink></para></listitem>

	<listitem id="xsltproc"><para>xsltproc is the xslt c library for gnome. this program is a way to use the library <emphasis>libxslt</emphasis> with a commande line tool for applying XSLT stylesheets to XML documents. </para></listitem>
	</orderedlist>
    </sect1>
    <sect1 id="written"><title>Handwriting of a handbook's part</title>
	<para>Some works on the Tulip project lead to make an part of a handbook for developer or users. We use the docbook utilities to create them. 
	DocBook is an SGML document type definition (DTD). An XML version is available now. SGML is an standard that describes how markup languages are defined. SGML does not consist of particular tags or the rules for their usage. HTML is an example of a markup language defined in SGML. On the other hand, XML is intended to alleviate compatibility problems with browser software. It's a new, easier version of the standard rules that govern the markup itself. 
	</para>

	<para>For each document, an .docbook file is created. To help the editing of the handbook, it is possible to use general editor like kate, emacs, quanta. See <ulink  url="http://i18n.kde.org/doc/doc-primer/docbook-editors.html"> DocBook Editors</ulink>. To configure Kate, select <filename>Configure Kate</filename> -> <filename>Settings</filename> -> <filename>Configure Kate</filename>. Select the plugin item from the application tree and check the <filename>Kate XML Completion</filename>, and the <filename>Kate XML Validation</filename> boxes. Then, the common files for generating documentations are in a directory named <filename>common</filename>. It locates in <filename>docs</filename> of the Tulip directory.</para>

	<sect2 id="elements"><title>Some elements to make easily a .docbook file</title>
	    <para>
	    <programlistingco>
	    <areaspec>
		<area id="xml" coords='2'/> 
		<area id="comments" coords='3'/>
		<area id="doctype" coords='4'/>
	    </areaspec>
<programlisting>
&lt;?xml version='1.0'?&gt;
<emphasis>&lt;!-- My first DocBook file --></emphasis>
&lt;!DOCTYPE book PUBLIC "-//OASIS//DTD Docbook XML V4.4//EN"
    "/usr/share/sgml/docbook/xml-dtd-4.4-1.0-27/docbookx.dtd"&gt;
	    </programlisting>
	    <calloutlist>
		<callout arearefs="xml">
		    <para>defined that it is a xml document version 1.0</para>
		</callout>

		<callout arearefs="comments">
		<para>the comments are writing between this two tags</para>
		</callout>

		<callout arearefs="doctype">
		<para>DTD, Document Type Declaration</para>
		</callout>
	    </calloutlist>
	    </programlistingco>
            The identification of the DTD is used by the document to know which root element is. Here, <quote>OASIS</quote> is the owner, the declaration is <quote>DTD XML V4.4</quote> and the language is English <quote>EN</quote>. the keyword <quote>book</quote> specifies that the root element is <emphasis>book</emphasis>. An example of the structure of a Docbook file is like followed.
<programlisting>
&lt;!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V4.4//EN">
&lt;book> 
    &lt;bookinfo> 
	&lt;title>My First Book&lt;/title>

	&lt;author>&lt;firstname>Jean-Pierre&lt;/firstname>&lt;surname>DUPONT&lt;/surname>&lt;/author>
	&lt;copyright>&lt;year>2005&lt;/year>&lt;holder>Jean-Pierre DUPONT&lt;/holder>&lt;/copyright>
    &lt;/bookinfo>
    &lt;preface> ... &lt;/preface>
    &lt;chapter> ... &lt;/chapter>
    &lt;chapter> ... &lt;/chapter>
    &lt;chapter> ... &lt;/chapter>
    &lt;appendix> ... &lt;/appendix>
    &lt;appendix> ... &lt;/appendix>
    &lt;index> ... &lt;/index>
&lt;/book>
</programlisting>
        A validating parser is a program that can read the DTD and determine whether the exact order of elements in the document is valid according to the DTD. To determinate if the XML code is valid, the programm <emphasis>meinproc</emphasis> is used in <filename>Makefile</filename> with the option --check. <cmdsynopsis><command>meinproc</command><arg><option>--check</option> myfile.docbook</arg></cmdsynopsis>
        </para>

        <para>It exists several attempts to produce an print or web publishing. Recently, the XML workgroup has made a standard Extensible Style Language (XSL). </para>

        <para></para>
	</sect2>
    </sect1>
    <sect1 id="doxygen"><title>Doxygen</title>
	<para>Doxygen is a documentation system for several languages like C++. It can generate an on-line documentation browser (in HTML), a set of manpages and/or an off-line reference manual (in LaTeX) or other from the set of documented source files of your project. This kind of documentation is a necessary tool for developers to find informations about the code. It is not a way to explain how is it imagined but which possibilities you have. See the web site of Doxygen : <ulink url="http://www.doxygen.org">http://www.doxygen.org</ulink>. It is available for several distributions like Fedora Core, Debian, Gentoo and others,..  Windows, MacOs and Sun Solaris too.
	</para>
	<para>To create your first doxygen documentation, you need a config file .cfg or .doxygen. To generate it :
	<cmdsynopsis><command>doxygen</command><arg><option>-g</option> myfile.doxygen</arg></cmdsynopsis>
	Several comments indicates how to use variables of the config file. this variables is useful to specify informations about your project and what you want to obtain. The INPUT tag contains the files or directories that contains your sources files. When you have set all tags with good values, you can generate the documentations.
	<cmdsynopsis><command>doxygen</command><arg>myfile.doxygen</arg></cmdsynopsis>
	it creates directories containing the documentations.
	</para>
        <para>For the Tulip project, the configuration files are still created and are located in the subdirectory of the special library, for example in <filename>(tulip)/docs/doxygen/tulip-lib</filename>.</para>
	<sect2 id="contributions"><title>Developer contributions</title>
	    <para>This part of the documentation depends completely of the developer comments. It is important that developers lead the grammar rules of doxygen. On the web site of Doxygen, you can find the important informations to comment the code correctly.</para>
	    <para>So the documentation's blocks in the sources files are the C++ comment blocks. For each code item there are two types of descriptions, which together form the documentation: a brief description and detailed description
	    <screen>
/**
* <emphasis>detailed description</emphasis>
*/

or 

/*!
* <emphasis>detailed description</emphasis>
*/

or 

/*!
<emphasis>detailed description</emphasis>
*/

or others ....
		</screen>
	    To make a brief description, you can use the command <methodname>\brief</methodname>. This command ends at the end of a paragraph, so the detailed description follows after an empty line. An other option is to use a special C++ style comment which does not span more than one line.
<screen>
/*! \brief <emphasis>Brief description.............
*         ......... continued ......</emphasis>
*
*  Detailed description
*/

or 

/// <emphasis>Brief description </emphasis>
/** <emphasis>Detailed description. </emphasis>*/

or 

//! <emphasis>Brief descripion.</emphasis>

//! <emphasis>Detailed description </emphasis>
//! <emphasis>starts here.</emphasis>

or others ....
	    </screen>
	    For more details, the web site of <ulink url="http://www.doxygen.org/docblocks.html">Doxygen</ulink> explains it. 
	    In general, the comments must be before the declaration or definition of a type, a function or a member. If you want to putting the documention after, you add a marker &lt;. Note that you can place your comment at other places using some tags like \class, \union, \fn, \var, ... or @class, @union, @fn, @var, ...
	    </para>
	    <para>
	    It exists several tags to help you for commenting and writing a description : 
	    <itemizedlist>
		<listitem><para>@author, name of the author. </para></listitem>
		<listitem><para>@param, to write a special comment on a parameter of a method or function. </para></listitem>
		<listitem><para>@see, to make a reference to an other object or function. </para></listitem>
		<listitem><para>@return, to indicate the exit of a function. </para></listitem>
		<listitem><para>@date, date of creation</para></listitem>
		<listitem><para>@note, desribe a role</para></listitem>
		<listitem><para>@attention, write a caution</para></listitem>
		<listitem><para>@warning</para></listitem>
		<listitem><para>@pre, write a prerequisite</para></listitem>
		<listitem><para>@remark</para></listitem>
	    </itemizedlist>
	    </para>
	</sect2>
    </sect1>
</chapter>
</book>
