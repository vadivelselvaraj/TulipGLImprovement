#include <iostream>
#include <time.h>
#include <string.h>

#include <tulip/TulipPlugin.h>
#include <tulip/Coord.h>
#include <tulip/AbstractProperty.h>
#include <tulip/GraphImpl.h>

#ifndef DOXYGEN_NOTFOR_DEVEL

#define TLP_FILE_VERSION "2.1"

using namespace std;
using namespace tlp;

static string convert(const string & tmp) {
  string newStr;
  for (unsigned int i=0; i<tmp.length(); ++i) {
    if (tmp[i]=='\"')
      newStr+="\\\"";
    else
      if (tmp[i]=='\n')
	newStr+="\\n";
      else
	if (tmp[i] == '\\')
	  newStr+="\\\\";
	else
	  newStr+=tmp[i];
  }
  return newStr;
}

static const char* boolTN, *colorTN, *coordTN, *doubleTN, *floatTN, *intTN, *sizeTN, *stringTN, *uintTN, *DataSetTN;
static bool typesInited = false;

namespace {
  static const char * paramHelp[] = {
    // name
    HTML_HELP_OPEN() \
    HTML_HELP_DEF( "type", "string" ) \
    HTML_HELP_DEF( "default", "" ) \
    HTML_HELP_BODY() \
    "Indicates the name of this graph." \
    HTML_HELP_CLOSE(),
    // author
    HTML_HELP_OPEN() \
    HTML_HELP_DEF( "type", "string" ) \
    HTML_HELP_DEF( "default", "" ) \
    HTML_HELP_BODY() \
    "Indicates the author of this graph." \
    HTML_HELP_CLOSE(),
    // comments
    HTML_HELP_OPEN() \
    HTML_HELP_DEF( "type", "string" ) \
    HTML_HELP_DEF( "default", "This file was generated by Tulip." ) \
    HTML_HELP_BODY() \
    "adds some comments." \
    HTML_HELP_CLOSE(),
    // format
    HTML_HELP_OPEN() \
    HTML_HELP_DEF( "type", "string" ) \
    HTML_HELP_DEF( "default", "2.1" ) \
    HTML_HELP_BODY() \
    "Indicates the storage format. Choose 2.0 for compatibility if compatibility with older version of Tulip is needed ." \
    HTML_HELP_CLOSE(),
  };
}

// workaround for G++ bug for <<
inline void printGraph(std::ostream &os, tlp::Graph *graph) {
  os << graph << endl;
}

namespace tlp {
#endif //DOXYGEN_NOTFOR_DEVEL

/** \addtogroup export */
/*@{*/
/// Export plugin for TLP format.
/**
 * This plugin records a Tulip graph structure in a file using the TLP format.
 * TLP is the Tulip Software Graph Format.
 * See 'Tulip-Software.org->Docs->TLP File Format' for description.
 * Note: When using the Tulip graphical user interface,
 * choosing "File->Export->TLP" menu item is the same that using
 * "File->Save as" menu item.
 */
class TLPExport:public ExportModule {
public:
  DataSet controller;
  bool useOldFormat;
  map<unsigned int, node>* nodeIndex;
  map<unsigned int, edge>* edgeIndex;

  TLPExport(AlgorithmContext context):ExportModule(context),
				      useOldFormat(false),
				      nodeIndex(NULL), edgeIndex(NULL) {
    addParameter<StringCollection>("format", paramHelp[3], "2.1;2.0");
    addParameter<string>("name", paramHelp[0]);
    addParameter<string>("author", paramHelp[1]);
    addParameter<string>("text::comments", paramHelp[2], "This file was generated by Tulip.");
    addParameter<DataSet>("controller");
  }
  //=====================================================
  ~TLPExport() {
    if (nodeIndex)
      delete nodeIndex;
    if (edgeIndex)
      delete edgeIndex;
  }
  //====================================================
  node getNode(node n) {
    return nodeIndex ? (*nodeIndex)[n.id] : n;
  }
  //====================================================
  edge getEdge(edge e) {
    return edgeIndex ? (*edgeIndex)[e.id] : e;
  }
  //=====================================================
  void saveGraphElements(ostream &os, Graph *graph) {
    if (graph->getSuperGraph() != graph) {
      os << "(cluster " << graph->getId() << " \"" << convert(graph->getAttribute<string>("name")) << "\"" << endl;
      Iterator<node> *itN = graph->getNodes();
      node beginNode, previousNode;
      if (itN->hasNext()) {
	os << "(nodes";
	while (itN->hasNext()) {
	  node current = getNode(itN->next());
	  if (useOldFormat) {
	    os << " " << current.id;
	  } else {
	    if (!beginNode.isValid()) {
	      beginNode = previousNode = current;
	      os << " " << beginNode.id;
	    } else {
	      if (current.id == previousNode.id + 1) {
		previousNode = current;
		if (!itN->hasNext())
		  os << ".." << current.id;
	      } else {
		if (previousNode != beginNode) {
		  os << ".." << previousNode.id;
		}
		os  << " " << current.id;
		beginNode = previousNode = current;
	      }
	    }
	  }
	}
	os << ")" << endl;
      } delete itN;
      Iterator<edge> *itE = graph->getEdges();
      edge beginEdge, previousEdge;
      if (itE->hasNext()) {
	os << "(edges";
	while (itE->hasNext()) {
	  edge current = getEdge(itE->next());
	  if (useOldFormat) {
	    os << " " << current.id;
	  } else {	  
	    if (!beginEdge.isValid()) {
	      beginEdge = previousEdge = current;
	      os << " " << beginEdge.id;
	    } else {
	      if (current.id == previousEdge.id + 1) {
		previousEdge = current;
		if (!itE->hasNext())
		  os << ".." << current.id;
	      } else {
		if (previousEdge != beginEdge) {
		  os << ".." << previousEdge.id;
		}
		os  << " " << current.id;
		beginEdge = previousEdge = current;
	      }
	    }
	  }
	}
	os << ")" << endl;
      } delete itE;
    }
    else {
       unsigned int nbElts = graph->numberOfNodes();
      // added in 2.1
      if (!useOldFormat)
	os << "(nb_nodes " << nbElts << ")" << endl;
      os << ";(nodes <node_id> <node_id> ...)" << endl;
      if (useOldFormat) {
	os << "(nodes";
	for (unsigned int i = 0; i < nbElts; ++i)
	  os << " " << i;
	os << ")" << endl;
      } else { // added in 2.1
	switch(nbElts) {
	case 0:
	  os << "(nodes)" << endl;
	  break;
	case 1:
	  os << "(nodes 0)" << endl;
	  break;
	case 2:
	  os << "(nodes 0 1)" << endl;
	  break;
	default:
	  os << "(nodes 0.." << nbElts - 1 << ")" << endl;
	}
      }
      // added in 2.1
      if (!useOldFormat) {
	nbElts = graph->numberOfEdges();
	os << "(nb_edges " << nbElts << ")" << endl;
      }
      os << ";(edge <edge_id> <source_id> <target_id>)" << endl;

      Iterator<edge> *ite = graph->getEdges();
      unsigned int id = 0;
      for (;ite->hasNext();) {
	edge e = ite->next();
	const pair<node, node>& ends = graph->ends(e);
	os << "(edge " << id << " " << getNode(ends.first).id << " " << getNode(ends.second).id << ")";
	if (ite->hasNext()) os << endl;
	id++;
      } delete ite;
      os << endl;
    }
    
    Iterator<Graph *> *itS = graph->getSubGraphs();
    while (itS->hasNext())
      saveGraphElements(os,itS->next());
    delete itS;
    if (graph->getSuperGraph() != graph)  os << ")" << endl;
  }
  //=====================================================
  void saveLocalProperties(ostream &os, Graph *graph) {
    Iterator<PropertyInterface *> *itP=graph->getLocalObjectProperties();
    PropertyInterface *prop;
    while (itP->hasNext()) {
      prop = itP->next();
      if (graph->getSuperGraph()==graph)
	os << "(property " << " 0 " << prop->getTypename() << " " ;
      else
	os << "(property " << " " << graph->getId() << " " << prop->getTypename() << " " ;
      os << "\"" << convert(prop->getName()) << "\"" << endl;
      string nDefault = prop->getNodeDefaultStringValue();
      string eDefault = prop->getEdgeDefaultStringValue();
      // replace real path with symbolic one using TulipBitmapDir
      if (prop->getName() == string("viewFont")) {
	size_t pos = nDefault.find(TulipBitmapDir);
	if(pos != string::npos)
	  nDefault.replace(pos, TulipBitmapDir.size(), "TulipBitmapDir/");
	pos = eDefault.find(TulipBitmapDir);
	if(pos != string::npos)
	  eDefault.replace(pos, TulipBitmapDir.size(), "TulipBitmapDir/");
      }
      os <<"(default \"" << convert(nDefault) << "\" \"" << convert(eDefault) << "\")" << endl;
      Iterator<node> *itN = prop->getNonDefaultValuatedNodes();
      while (itN->hasNext()) {
	node itn = itN->next();
	if (!graph->isElement(itn))
	  continue;
	string tmp = prop->getNodeStringValue(itn);
	// replace real path with symbolic one using TulipBitmapDir
	if (prop->getName() == string("viewFont")) {
	  size_t pos = tmp.find(TulipBitmapDir);
	  if (pos != string::npos)
	    tmp.replace(pos, TulipBitmapDir.size(), "TulipBitmapDir/");
	}
	os << "(node " << getNode(itn).id << " \"" << convert(tmp) << "\")" << endl ;
      } delete itN;
      Iterator<edge> *itE = prop->getNonDefaultValuatedEdges();
      while (itE->hasNext()) {
	edge ite = itE->next();
	if (!graph->isElement(ite))
	  continue;
	// replace real path with symbolic one using TulipBitmapDir
	string tmp = prop->getEdgeStringValue(ite);
	if (prop->getName() == string("viewFont")) {
	  size_t pos = tmp.find(TulipBitmapDir);
	  if (pos != string::npos)
	    tmp.replace(pos, TulipBitmapDir.size(), "TulipBitmapDir/");
	}
	os << "(edge " << getEdge(ite).id << " \"" << convert(tmp) << "\")" << endl ;
      } delete itE;
      os << ")" << endl;
    }
    delete itP;
  }
  //=====================================================
  void saveProperties(ostream &os,Graph *graph) {
    saveLocalProperties(os,graph);
    Iterator<Graph *> *itS=graph->getSubGraphs();
    while (itS->hasNext())
      saveProperties(os,itS->next());
    delete itS;
  }
  //=====================================================
  void initTypeNames() {
    if (!typesInited) {
      boolTN = typeid(typesInited).name();
      Color color;
      colorTN = typeid(color).name();
      Coord coord;
      coordTN = typeid(coord).name();
      double d;
      doubleTN = typeid(d).name();
      float f;
      floatTN = typeid(f).name();
      int i;
      intTN = typeid(i).name();
      Size siz;
      sizeTN = typeid(siz).name();
      string s;
      stringTN = typeid(s).name();
      unsigned int ui;
      uintTN = typeid(ui).name();
      DataSet dataSet;
      DataSetTN = typeid(dataSet).name();
      typesInited = true;
    }
  }
  //=====================================================
  void saveDataSet(ostream &os, const DataSet &data) {
    initTypeNames();
    // get iterator over pair attribute/value
    Iterator< pair<string, DataType*> > *it = data.getValues();
    while( it->hasNext() ) {
      pair<string, DataType*> p;
      p = it->next();
      const string tn = p.second->typeName;
       // get output type name
      if (tn == boolTN)
	os << '(' << "bool";
      else if (tn == colorTN)
	os << '(' << "color";
      else if (tn == coordTN)
	os << '(' << "coord";
      else if (tn == doubleTN)
	os << '(' << "double";
      else if (tn == floatTN)
	os << '(' << "float";
      else if (tn == intTN)
	os << '(' << "int";
      else if (tn == sizeTN)
	os << '(' << "size";
      else if (tn == stringTN)
	os << '(' << "string";
      else if (tn == uintTN)
	os << '(' << "uint";
      else if (tn == DataSetTN)
	os << '(' << "DataSet";
      // general case do nothing
      else continue;
      // output attribute name
      os << " \"" << p.first << "\" ";
      // output value
      // special cases
      if (tn == boolTN)
	os << ((*(bool*)p.second->value) ? "true" : "false");
      else if (tn == colorTN) {
	Color *color = (Color*) p.second->value;
	//os << "\"(" << (int)color->getR() << ',' << (int)color->getG() << ',' << (int) color->getB() << ",0)\"";
	os << "\"" << convert(ColorType::toString(*color)) << "\"";
      } else if (tn == coordTN) {
	Coord *coord =  (Coord*) p.second->value;
	//os << "\"(" << coord->getX() << "," << coord->getY() << "," << coord->getZ() << ")\"";
	os << "\"" << convert(PointType::toString(*coord)) << "\"";
      } else if (tn == sizeTN) {
	Size *size =  (Size*) p.second->value;
	//os << "\"(" << size->getW() << "," << size->getH() << "," << size->getD() << ")\"";
	os << "\"" << convert(SizeType::toString(*size)) << "\"";
      }	else if (tn == DataSetTN) {
	os << endl;
	DataSet *dataSet = (DataSet*) p.second->value;
	saveDataSet(os, *dataSet);
      }else if (tn == doubleTN)
	os << *(double*)p.second->value;
      else if (tn == floatTN)
	os << *(float*)p.second->value;
      else if (tn == intTN)
	os << *(int*)p.second->value;
      else if (tn == stringTN)
	os << '"' << *(string *)p.second->value << '"';
      else if (tn == uintTN)
	os << *(unsigned int *) p.second->value;
      // output closed parenthesis
      os << ')' << endl;
    } delete it;
  }
  //=====================================================
  void saveAttributes(ostream &os, Graph *graph) {
    os << "(attributes " << endl;
    saveDataSet(os, graph->getAttributes());
    os << ")" << endl;
  }
  //=====================================================
  void saveController(ostream &os, DataSet &data) {
    os << "(controller " << endl;
    saveDataSet(os, data);
    os << ")" << endl;
  }

  bool exportGraph(ostream &os,Graph *currentGraph) {
    nodeIndex = NULL;
    edgeIndex = NULL;
    graph=currentGraph->getRoot();
    string format(TLP_FILE_VERSION);

    // reindex nodes/edges if needed
    if (((GraphImpl *) graph)->hasFragmentedNodeIds()) {
      nodeIndex = new map<unsigned int, node>;
      unsigned int i = 0;
      node n;
      forEach(n, graph->getNodes()) {
	(*nodeIndex)[n.id] = node(i);
	i++;
      }
    }
    if (((GraphImpl *) graph)->hasFragmentedEdgeIds()) {
      edgeIndex = new map<unsigned int, edge>;
      unsigned int i = 0;
      edge e;
      forEach(e, graph->getEdges()) {
	(*edgeIndex)[e.id] = edge(i);
	i++;
      }
    }
    
    string name;
    string author;
    string comments;

    if (dataSet != NULL) {
      StringCollection tmp;
      dataSet->get("name", name);
      dataSet->get("author", author);
      dataSet->get("text::comments", comments);
      if (dataSet->get("format", tmp))
	format = tmp.getCurrentString();
    }

    if (format != string(TLP_FILE_VERSION))
      useOldFormat = true;

    if (name.length() > 0)
      graph->setAttribute("name", name);

    // get ostime
    time_t ostime = time(NULL);
    // get local time
    struct tm *currTime = localtime(&ostime);
    // format date
    char currDate[32];
    strftime(currDate, 32, "%m-%d-%Y", currTime);

    // output tlp format version
    os << "(tlp \"" << format.c_str() << '"' << endl;
    // current date
    os << "(date \"" << currDate << "\")" << endl;
    // author
    if (author.length() > 0)
      os << "(author \"" << author << "\")" << endl;
    // comments
    os << "(comments \"" << comments << "\")" << endl;

    saveGraphElements(os,graph);
    saveProperties(os,graph);
    saveAttributes(os,graph);

    //Save displaying
    //    DataSet displaying;
    /*if (dataSet != NULL && dataSet->get<DataSet>("displaying", displaying))
      saveDisplaying(os, displaying);*/

    //Save views
     if (dataSet != NULL && dataSet->get<DataSet>("controller", controller))
      saveController(os, controller);

    os << ')' << endl; // end of (tlp ...
    if (nodeIndex) {
      delete nodeIndex;
      nodeIndex = NULL;
    }
    if (edgeIndex) {
      delete edgeIndex;
      edgeIndex = NULL;
    }
    return true;
  }
};
  EXPORTPLUGIN(TLPExport,"tlp","Auber David","31/07/2001","TLP Export plugin", "1.1");
/*@}*/
}
